#!/usr/bin/env python
import importlib
import logging
import os

# Trigger an eager import of every module we can find in order to load up the registered nodes.
import pkgutil
import textwrap
from collections import defaultdict
from typing import Dict, List, Set

import typer

import treeno
from treeno.base import GenericSql, Sql

_DEFAULT_OUTPUT_FILE = os.path.join(
    os.path.dirname(__file__), "../../treeno/visitor.py"
)

for loader, module_name, is_pkg in pkgutil.walk_packages(
    treeno.__path__, treeno.__name__ + "."
):
    # Ignore the visitor class itself.
    if module_name == "treeno.visitor":
        continue
    # No need to actually store the loaded modules, we just need to trigger
    # the registration to Sql
    importlib.import_module(module_name)

# Spaces > tabs
INDENT = " " * 4


def get_import_paths(sqls: Set[GenericSql]) -> Dict[str, List[str]]:
    module_map = defaultdict(list)
    # Find their import paths
    for node in sqls:
        module_map[node.__module__].append(node.__name__)
    return module_map


def generate_import_statements(module_map: Dict[str, List[str]]) -> List[str]:
    code = []
    code.append("from treeno.base import GenericSql")
    for mod, sqls in module_map.items():
        sqls_string = ",".join(sqls)
        code.append(f"from {mod} import {sqls_string}")
    return code


def generate_function_stubs(sqls: Set[GenericSql]) -> List[str]:
    code = []
    # Generic function to visit any class by getattr'ing
    code.append('def visit(self, node: "GenericSql") -> T:')
    code.append(
        textwrap.indent(
            'return getattr(self, f"visit_{node.__class__.__name__}")(node)',
            INDENT,
        )
    )
    for node in sqls:
        class_name = node.__name__
        code.append(f'def visit_{class_name}(self, node: "{class_name}") -> T:')
        code.append(textwrap.indent("...", INDENT))
    return code


def generate_visitor(
    file_name: str = _DEFAULT_OUTPUT_FILE, replace: bool = False
) -> None:
    file_exists = os.path.exists(file_name)
    if not replace:
        assert (
            not file_exists
        ), f"File already exists at {file_name}. Move/delete it before generating a new visitor file."
    elif file_exists:
        print(f"File {file_name} found with replace=True. Deleting the file")
        os.remove(file_name)

    code = [
        "# AUTOGENERATED BY create_visitor.py",
        # Wrap the imports with TYPE_CHECKING to avoid unnecessary import runtime bloat
        "from typing import TYPE_CHECKING, Generic, TypeVar",
        "T = TypeVar('T')",
    ]

    registered_nodes = set()

    for node in Sql._REGISTERED_NODES:
        # TODO: Currently we don't support Lambda.Variable and other nested
        # classes, should come up with a naming scheme for them in autogenerated
        # visitor fn and expose them.
        if node.__name__ != node.__qualname__:
            logging.warn(
                f"Node {node.__qualname__} is currently excluded from visitor codegen."
            )
            continue
        registered_nodes.add(node)

    module_map = get_import_paths(registered_nodes)
    code.extend(["if TYPE_CHECKING:"])
    code.extend(
        [
            textwrap.indent(import_line, INDENT)
            for import_line in generate_import_statements(module_map)
        ]
    )
    code.extend(["class TreenoVisitor(Generic[T]):"])
    code.extend(
        [
            textwrap.indent(fn_line, INDENT)
            for fn_line in generate_function_stubs(registered_nodes)
        ]
    )
    with open(file_name, "w") as f:
        f.write("\n".join(code))


if __name__ == "__main__":
    typer.run(generate_visitor)
